/* automatically generated by rust-bindgen 0.61.0 */

use crate::{cadef::ca_access_rights, thread::*};

pub const CA_OP_GET: i32 = 0;
pub const CA_OP_PUT: i32 = 1;
pub const CA_OP_CREATE_CHANNEL: i32 = 2;
pub const CA_OP_ADD_EVENT: i32 = 3;
pub const CA_OP_CLEAR_EVENT: i32 = 4;
pub const CA_OP_OTHER: i32 = 5;
pub const CA_OP_CONN_UP: i32 = 6;
pub const CA_OP_CONN_DOWN: i32 = 7;
pub const CA_OP_SEARCH: i32 = 2;
pub const TYPENOTCONN: i32 = -1;
pub const CA_PRIORITY_MAX: i32 = 99;
pub const CA_PRIORITY_MIN: i32 = 0;
pub const CA_PRIORITY_DEFAULT: i32 = 0;
pub const CA_PRIORITY_DB_LINKS: i32 = 80;
pub const CA_PRIORITY_ARCHIVE: i32 = 20;
pub const CA_PRIORITY_OPI: i32 = 0;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct oldChannelNotify {
    _unused: [u8; 0],
}
pub type chid = *mut oldChannelNotify;
pub type chanId = chid;
pub type chtype = libc::c_long;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct oldSubscription {
    _unused: [u8; 0],
}
pub type evid = *mut oldSubscription;
pub type ca_real = f64;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct connection_handler_args {
    pub chid: chanId,
    pub op: libc::c_long,
}
pub type caCh = ::core::option::Option<unsafe extern "C" fn(args: connection_handler_args)>;
pub type caar = ca_access_rights;
#[repr(C)]
pub struct access_rights_handler_args {
    pub chid: chanId,
    pub ar: caar,
}
pub type caArh = ::core::option::Option<unsafe extern "C" fn(args: access_rights_handler_args)>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct event_handler_args {
    pub usr: *mut libc::c_void,
    pub chid: chanId,
    pub type_: libc::c_long,
    pub count: libc::c_long,
    pub dbr: *const libc::c_void,
    pub status: libc::c_int,
}
pub type evargs = event_handler_args;
pub type caEventCallBackFunc =
    ::core::option::Option<unsafe extern "C" fn(arg1: event_handler_args)>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct exception_handler_args {
    pub usr: *mut libc::c_void,
    pub chid: chanId,
    pub type_: libc::c_long,
    pub count: libc::c_long,
    pub addr: *mut libc::c_void,
    pub stat: libc::c_long,
    pub op: libc::c_long,
    pub ctx: *const libc::c_char,
    pub pFile: *const libc::c_char,
    pub lineNo: libc::c_uint,
}
pub type CA_SYNC_GID = libc::c_uint;
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum channel_state {
    cs_never_conn = 0,
    cs_prev_conn = 1,
    cs_conn = 2,
    cs_closed = 3,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum ca_preemptive_callback_select {
    ca_disable_preemptive_callback = 0,
    ca_enable_preemptive_callback = 1,
}
pub type capri = libc::c_uint;
pub type caExceptionHandler =
    ::core::option::Option<unsafe extern "C" fn(arg1: exception_handler_args)>;
pub type CAFDHANDLER = ::core::option::Option<
    unsafe extern "C" fn(parg: *mut libc::c_void, fd: libc::c_int, opened: libc::c_int),
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ca_client_context {
    _unused: [u8; 0],
}
extern "C" {
    pub fn ca_test_event(arg1: event_handler_args);
    pub fn ca_field_type(chan: chid) -> libc::c_short;
    pub fn ca_element_count(chan: chid) -> libc::c_ulong;
    pub fn ca_name(chan: chid) -> *const libc::c_char;
    pub fn ca_set_puser(chan: chid, puser: *mut libc::c_void);
    pub fn ca_puser(chan: chid) -> *mut libc::c_void;
    pub fn ca_read_access(chan: chid) -> libc::c_uint;
    pub fn ca_write_access(chan: chid) -> libc::c_uint;
    pub fn ca_state(chan: chid) -> channel_state;
    pub fn ca_task_initialize() -> libc::c_int;
    pub fn ca_context_create(select: ca_preemptive_callback_select) -> libc::c_int;
    pub fn ca_detach_context();
    pub fn ca_task_exit() -> libc::c_int;
    pub fn ca_context_destroy();
    pub fn ca_create_channel(
        pChanName: *const libc::c_char,
        pConnStateCallback: caCh,
        pUserPrivate: *mut libc::c_void,
        priority: capri,
        pChanID: *mut chid,
    ) -> libc::c_int;
    pub fn ca_change_connection_event(chan: chid, pfunc: caCh) -> libc::c_int;
    pub fn ca_replace_access_rights_event(chan: chid, pfunc: caArh) -> libc::c_int;
    pub fn ca_add_exception_event(
        pfunc: caExceptionHandler,
        pArg: *mut libc::c_void,
    ) -> libc::c_int;
    pub fn ca_clear_channel(chanId: chid) -> libc::c_int;
    pub fn ca_array_put(
        type_: chtype,
        count: libc::c_ulong,
        chanId: chid,
        pValue: *const libc::c_void,
    ) -> libc::c_int;
    pub fn ca_array_put_callback(
        type_: chtype,
        count: libc::c_ulong,
        chanId: chid,
        pValue: *const libc::c_void,
        pFunc: caEventCallBackFunc,
        pArg: *mut libc::c_void,
    ) -> libc::c_int;
    pub fn ca_array_get(
        type_: chtype,
        count: libc::c_ulong,
        chanId: chid,
        pValue: *mut libc::c_void,
    ) -> libc::c_int;
    pub fn ca_array_get_callback(
        type_: chtype,
        count: libc::c_ulong,
        chanId: chid,
        pFunc: caEventCallBackFunc,
        pArg: *mut libc::c_void,
    ) -> libc::c_int;
    pub fn ca_create_subscription(
        type_: chtype,
        count: libc::c_ulong,
        chanId: chid,
        mask: libc::c_long,
        pFunc: caEventCallBackFunc,
        pArg: *mut libc::c_void,
        pEventID: *mut evid,
    ) -> libc::c_int;
    pub fn ca_clear_subscription(eventID: evid) -> libc::c_int;
    pub fn ca_evid_to_chid(id: evid) -> chid;
    pub fn ca_pend_event(timeOut: ca_real) -> libc::c_int;
    pub fn ca_pend_io(timeOut: ca_real) -> libc::c_int;
    pub fn ca_pend(timeout: ca_real, early: libc::c_int) -> libc::c_int;
    pub fn ca_test_io() -> libc::c_int;
    pub fn ca_flush_io() -> libc::c_int;
    pub fn ca_signal(errorCode: libc::c_long, pCtxStr: *const libc::c_char);
    pub fn ca_signal_with_file_and_lineno(
        errorCode: libc::c_long,
        pCtxStr: *const libc::c_char,
        pFileStr: *const libc::c_char,
        lineNo: libc::c_int,
    );
    pub fn ca_signal_formated(
        ca_status: libc::c_long,
        pfilenm: *const libc::c_char,
        lineno: libc::c_int,
        pFormat: *const libc::c_char,
        ...
    );
    pub fn ca_host_name(channel: chid) -> *const libc::c_char;
    pub fn ca_get_host_name(
        pChan: chid,
        pBuf: *mut libc::c_char,
        bufLength: libc::c_uint,
    ) -> libc::c_uint;
    pub fn ca_add_fd_registration(pHandler: CAFDHANDLER, pArg: *mut libc::c_void) -> libc::c_int;
    pub fn ca_sg_create(pgid: *mut CA_SYNC_GID) -> libc::c_int;
    pub fn ca_sg_delete(gid: CA_SYNC_GID) -> libc::c_int;
    pub fn ca_sg_block(gid: CA_SYNC_GID, timeout: ca_real) -> libc::c_int;
    pub fn ca_sg_test(gid: CA_SYNC_GID) -> libc::c_int;
    pub fn ca_sg_reset(gid: CA_SYNC_GID) -> libc::c_int;
    pub fn ca_sg_array_get(
        gid: CA_SYNC_GID,
        type_: chtype,
        count: libc::c_ulong,
        chan: chid,
        pValue: *mut libc::c_void,
    ) -> libc::c_int;
    pub fn ca_sg_array_put(
        gid: CA_SYNC_GID,
        type_: chtype,
        count: libc::c_ulong,
        chan: chid,
        pValue: *const libc::c_void,
    ) -> libc::c_int;
    pub fn ca_sg_stat(gid: CA_SYNC_GID) -> libc::c_int;
    pub fn ca_dump_dbr(type_: chtype, count: libc::c_uint, pbuffer: *const libc::c_void);
    pub fn ca_v42_ok(chan: chid) -> libc::c_int;
    pub fn ca_version() -> *const libc::c_char;
    pub fn ca_get_ioc_connection_count() -> libc::c_uint;
    pub fn ca_preemtive_callback_is_enabled() -> libc::c_int;
    pub fn ca_self_test();
    pub fn ca_beacon_anomaly_count() -> libc::c_uint;
    pub fn ca_search_attempts(chan: chid) -> libc::c_uint;
    pub fn ca_beacon_period(chan: chid) -> f64;
    pub fn ca_receive_watchdog_delay(chan: chid) -> f64;
    pub fn ca_current_context() -> *mut ca_client_context;
    pub fn ca_attach_context(context: *mut ca_client_context) -> libc::c_int;
    pub fn ca_client_status(level: libc::c_uint) -> libc::c_int;
    pub fn ca_context_status(arg1: *mut ca_client_context, level: libc::c_uint) -> libc::c_int;
    pub fn ca_build_and_connect(
        pChanName: *const libc::c_char,
        arg1: chtype,
        arg2: libc::c_ulong,
        pChanID: *mut chid,
        arg3: *mut libc::c_void,
        pFunc: caCh,
        pArg: *mut libc::c_void,
    ) -> libc::c_int;
    pub fn ca_search_and_connect(
        pChanName: *const libc::c_char,
        pChanID: *mut chid,
        pFunc: caCh,
        pArg: *mut libc::c_void,
    ) -> libc::c_int;
    pub fn ca_channel_status(tid: epicsThreadId) -> libc::c_int;
    pub fn ca_clear_event(eventID: evid) -> libc::c_int;
    pub fn ca_add_masked_array_event(
        type_: chtype,
        count: libc::c_ulong,
        chanId: chid,
        pFunc: caEventCallBackFunc,
        pArg: *mut libc::c_void,
        p_delta: ca_real,
        n_delta: ca_real,
        timeout: ca_real,
        pEventID: *mut evid,
        mask: libc::c_long,
    ) -> libc::c_int;
    pub fn ca_modify_user_name(pUserName: *const libc::c_char) -> libc::c_int;
    pub fn ca_modify_host_name(pHostName: *const libc::c_char) -> libc::c_int;
}
